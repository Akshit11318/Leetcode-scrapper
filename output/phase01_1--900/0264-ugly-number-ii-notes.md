## Ugly Number II
**Problem Link:** https://leetcode.com/problems/ugly-number-ii/description

**Problem Statement:**
- Input format and constraints: Given an integer `n`, return the `n`th ugly number. Ugly numbers are positive numbers whose only prime factors are 2, 3, or 5.
- Expected output format: The `n`th ugly number.
- Key requirements and edge cases to consider: 
    - `n` is within the range `[1, 1690]`.
    - The sequence starts with 1 and each subsequent number is generated by multiplying the previous number by 2, 3, or 5.
- Example test cases with explanations:
    - For `n = 10`, the output should be `12` because the sequence of ugly numbers starts as 1, 2, 3, 4, 5, 6, 8, 9, 10, 12.

---

### Brute Force Approach
**Explanation:**
- Initial thought process: The most straightforward approach is to generate all numbers and check if they are ugly by dividing them by 2, 3, and 5 until they are no longer divisible.
- Step-by-step breakdown of the solution:
    1. Start with a counter for ugly numbers found.
    2. Iterate through all positive integers, starting from 1.
    3. For each integer, check if it is an ugly number by continuously dividing it by 2, 3, and 5 as long as it is divisible.
    4. If after this process the number becomes 1, it is an ugly number. Increment the counter.
    5. Once the counter reaches `n`, return the current integer as the `n`th ugly number.
- Why this approach comes to mind first: It directly addresses the problem statement by checking each number to see if it meets the criteria for being an ugly number.

```cpp
int nthUglyNumber(int n) {
    int count = 0; // Counter for ugly numbers
    int num = 1; // Current number being checked
    while (true) {
        if (isUgly(num)) {
            count++;
            if (count == n) {
                return num;
            }
        }
        num++;
    }
}

bool isUgly(int num) {
    if (num == 1) return true; // 1 is considered an ugly number
    for (int i = 2; i <= num; i++) {
        if (num % i == 0) {
            if (i == 2 || i == 3 || i == 5) {
                while (num % i == 0) num /= i;
                if (num == 1) return true;
            } else {
                return false;
            }
        }
    }
    return false;
}
```

> Complexity Analysis:
> - **Time Complexity:** $O(n \cdot \log(n))$ because in the worst case, for each number up to `n`, we might divide it by 2, 3, or 5 until it reaches 1, which takes $\log(n)$ time.
> - **Space Complexity:** $O(1)$ since we use a constant amount of space.
> - **Why these complexities occur:** The time complexity is high because we check every number up to `n`, and for each, we perform division operations until it is no longer divisible by 2, 3, or 5.

---

### Optimal Approach (Required)
**Explanation:**
- Key insight that leads to optimal solution: Instead of checking every number to see if it is ugly, we can generate ugly numbers directly by maintaining a list of ugly numbers found so far and using them to generate the next ones.
- Detailed breakdown of the approach:
    1. Initialize a list with the first ugly number, which is 1.
    2. Maintain three pointers, each pointing to the last ugly number that was multiplied by 2, 3, or 5 to generate a new ugly number.
    3. At each step, find the smallest ugly number that can be generated by multiplying the current ugly numbers with 2, 3, or 5.
    4. Add this new ugly number to the list and move the corresponding pointer(s) forward.
- Proof of optimality: This approach ensures that we generate the `n`th ugly number in $O(n)$ time because we only generate ugly numbers and do not check non-ugly numbers.
- Why further optimization is impossible: This is because we must generate all ugly numbers up to the `n`th one to find it, and generating each one takes constant time.

```cpp
int nthUglyNumber(int n) {
    vector<int> ugly(n);
    ugly[0] = 1;
    int i2 = 0, i3 = 0, i5 = 0;
    for (int i = 1; i < n; i++) {
        int nextUgly = min({ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5});
        ugly[i] = nextUgly;
        if (nextUgly == ugly[i2] * 2) i2++;
        if (nextUgly == ugly[i3] * 3) i3++;
        if (nextUgly == ugly[i5] * 5) i5++;
    }
    return ugly[n - 1];
}
```

> Complexity Analysis:
> - **Time Complexity:** $O(n)$ because we generate `n` ugly numbers, each in constant time.
> - **Space Complexity:** $O(n)$ because we store `n` ugly numbers.
> - **Optimality proof:** This approach is optimal because it generates the `n`th ugly number directly without checking any non-ugly numbers, achieving the best possible time complexity for this problem.

---

### Final Notes

**Learning Points:**
- Key algorithmic concepts demonstrated: Dynamic programming and the use of pointers to track the generation of the next elements in a sequence.
- Problem-solving patterns identified: Generating sequences based on previous elements and using pointers to track the generation process.
- Optimization techniques learned: Avoiding unnecessary checks by directly generating the required sequence.
- Similar problems to practice: Generating other types of sequences, such as Fibonacci numbers or permutations.

**Mistakes to Avoid:**
- Common implementation errors: Incorrect handling of edge cases, such as when `n` is 1.
- Edge cases to watch for: Handling the first ugly number (1) and ensuring the generation of the sequence stops at the `n`th number.
- Performance pitfalls: Using brute force approaches for large `n`, which can lead to significant time complexity issues.
- Testing considerations: Ensure the function works correctly for small and large values of `n`, including edge cases like `n = 1`.