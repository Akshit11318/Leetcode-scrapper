## Find Pattern in Infinite Stream I
**Problem Link:** https://leetcode.com/problems/find-pattern-in-infinite-stream-i/description

**Problem Statement:**
- Input format: A string `pattern` and an integer `n`.
- Constraints: `1 <= n <= 10^6`, `1 <= pattern.length <= 100`.
- Expected output format: Return the nth string in the sequence of strings generated by the pattern.
- Key requirements: The sequence starts with the given pattern and each subsequent string is formed by appending the next string in the pattern to the previous string.
- Example test cases:
  - Input: `pattern = "abc", n = 5`
  - Output: `"abcab"`
  - Explanation: The sequence starts with "abc", then the next string is "abc" + "a" = "abca", then "abca" + "b" = "abcab", and so on.

---

### Brute Force Approach
**Explanation:**
- Initial thought process: To generate the sequence up to the nth string, we start with the given pattern and iteratively append the next character from the pattern to the current string.
- Step-by-step breakdown:
  1. Initialize the result string with the given pattern.
  2. Calculate the length of the pattern.
  3. For each subsequent string in the sequence, append the corresponding character from the pattern to the result string.
- Why this approach comes to mind first: It directly follows the problem statement's description of how the sequence is generated.

```cpp
string findPattern(string pattern, int n) {
    string result = pattern;
    int patternLength = pattern.length();
    int index = 0;
    for (int i = patternLength; i < n; i++) {
        result += pattern[index % patternLength];
        index++;
    }
    return result;
}
```

> Complexity Analysis:
> - **Time Complexity:** $O(n)$, where $n$ is the input integer, because we iterate up to $n$ times to generate the sequence.
> - **Space Complexity:** $O(n)$, because in the worst case, the length of the result string is $n$.
> - **Why these complexities occur:** The time complexity is linear because we perform a constant amount of work for each character in the sequence, and the space complexity is linear because we store the entire sequence in memory.

---

### Optimal Approach (Required)
**Explanation:**
- Key insight: Since the sequence is generated by appending characters from the pattern, we can directly calculate the nth string without generating the entire sequence.
- Detailed breakdown:
  1. Calculate the number of complete repetitions of the pattern up to the nth character.
  2. Determine the index within the pattern where the nth character falls.
  3. Construct the result string by concatenating the complete repetitions of the pattern and the remaining characters up to the nth character.
- Proof of optimality: This approach is optimal because it avoids generating unnecessary intermediate strings and directly computes the nth string.

```cpp
string findPattern(string pattern, int n) {
    int patternLength = pattern.length();
    int completeRepetitions = n / patternLength;
    int remainingCharacters = n % patternLength;
    string result = "";
    for (int i = 0; i < completeRepetitions; i++) {
        result += pattern;
    }
    for (int i = 0; i < remainingCharacters; i++) {
        result += pattern[i];
    }
    return result;
}
```

> Complexity Analysis:
> - **Time Complexity:** $O(n)$, where $n$ is the input integer, because we construct the result string up to the nth character.
> - **Space Complexity:** $O(n)$, because in the worst case, the length of the result string is $n$.
> - **Optimality proof:** This approach is optimal because it directly computes the nth string without generating unnecessary intermediate strings, achieving the best possible time and space complexity for this problem.

---

### Final Notes
**Learning Points:**
- Key algorithmic concepts demonstrated: String manipulation, sequence generation, and optimization techniques.
- Problem-solving patterns identified: Direct computation of the result instead of generating intermediate steps.
- Optimization techniques learned: Avoiding unnecessary computations and memory usage.
- Similar problems to practice: Other sequence generation problems, such as Fibonacci or tribonacci sequences.

**Mistakes to Avoid:**
- Common implementation errors: Incorrect indexing or off-by-one errors when working with strings and sequences.
- Edge cases to watch for: Handling cases where the input integer $n$ is less than or equal to the length of the pattern.
- Performance pitfalls: Generating unnecessary intermediate strings or using inefficient string concatenation methods.
- Testing considerations: Thoroughly testing the function with various input values, including edge cases and large inputs.