## Generalized Abbreviation

**Problem Link:** [https://leetcode.com/problems/generalized-abbreviation/description](https://leetcode.com/problems/generalized-abbreviation/description)

**Problem Statement:**
- Input format and constraints: The input is a string `word`. The length of `word` is between 1 and 16.
- Expected output format: A list of all possible generalized abbreviations of `word`.
- Key requirements and edge cases to consider: A generalized abbreviation of a word can be generated by removing one or more non-overlapping substrings from the original word. The result must contain at least one character.
- Example test cases with explanations:
  - Input: `"word"`
    - Output: `["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]`

---

### Brute Force Approach

**Explanation:**
- Initial thought process: Generate all possible substrings of the input word and remove them one by one to generate abbreviations.
- Step-by-step breakdown of the solution:
  1. Generate all possible substrings of the input word.
  2. For each substring, remove it from the word to generate a new abbreviation.
  3. Recursively apply this process to the new abbreviation.
- Why this approach comes to mind first: It's a straightforward way to think about generating all possible abbreviations by considering all possible removals of substrings.

```cpp
class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> result;
        dfs(word, 0, "", result);
        return result;
    }

    void dfs(string word, int start, string path, vector<string>& result) {
        if (start == word.size()) {
            result.push_back(path);
            return;
        }
        for (int i = start; i < word.size(); i++) {
            string newPath = path;
            if (path.empty() || !isdigit(path.back())) {
                newPath += word.substr(start, i - start + 1);
            } else {
                newPath += to_string(i - start + 1);
            }
            dfs(word, i + 1, newPath, result);
        }
    }
};
```

> Complexity Analysis:
> - **Time Complexity:** $O(2^n)$ where $n$ is the length of the input word. This is because in the worst case, we might end up exploring all possible substrings and their combinations.
> - **Space Complexity:** $O(n)$ due to the recursion stack and the space needed to store the result.
> - **Why these complexities occur:** The exponential time complexity is due to the recursive nature of the solution and the fact that we're exploring all possible combinations of substrings. The space complexity is linear because of the recursion stack and the storage needed for the result.

---

### Optimal Approach (Required)

**Explanation:**
- Key insight that leads to optimal solution: Instead of generating all substrings and removing them, we can use a bitmask to represent which characters to keep or remove. This approach is more efficient because it avoids the overhead of string manipulation and directly generates the abbreviations.
- Detailed breakdown of the approach:
  1. Use a bitmask where each bit corresponds to a character in the input word. A bit set to 1 means the character is kept, and a bit set to 0 means it's removed.
  2. Iterate through all possible bitmasks (from 0 to $2^n - 1$) and for each bitmask, generate the corresponding abbreviation.
- Proof of optimality: This approach is optimal because it generates all possible abbreviations in a single pass without any redundant work. The use of a bitmask allows for efficient representation and iteration over all possible combinations.

```cpp
class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> result;
        int n = word.size();
        for (int mask = 0; mask < (1 << n); mask++) {
            string abbr;
            int count = 0;
            for (int i = 0; i < n; i++) {
                if ((mask & (1 << i)) != 0) {
                    if (count > 0) {
                        abbr += to_string(count);
                        count = 0;
                    }
                    abbr += word[i];
                } else {
                    count++;
                }
            }
            if (count > 0) {
                abbr += to_string(count);
            }
            result.push_back(abbr);
        }
        return result;
    }
};
```

> Complexity Analysis:
> - **Time Complexity:** $O(2^n \cdot n)$ where $n$ is the length of the input word. The $2^n$ factor comes from iterating over all possible bitmasks, and the $n$ factor comes from generating the abbreviation for each bitmask.
> - **Space Complexity:** $O(n)$ due to the space needed to store the abbreviation being generated.
> - **Optimality proof:** This approach is optimal because it generates all possible abbreviations in a single pass without any redundant work, achieving the best possible time complexity for this problem.