## Find the Difference

**Problem Link:** https://leetcode.com/problems/find-the-difference/description

**Problem Statement:**
- Given two strings `s` and `t`, where `t` is generated by random shuffling of `s` and then adding a random character, find the character that was added to `t`.
- Input format: Two strings `s` and `t`.
- Constraints: 
    - `0 <= s.length <= 100`
    - `0 <= t.length <= 100`
    - `s` and `t` consist of lowercase English letters.
- Expected output format: The character that was added to `t`.
- Key requirements and edge cases to consider: 
    - Handle cases where `s` or `t` is empty.
    - Handle cases where the added character is repeated in `s`.
- Example test cases with explanations: 
    - `s = "abcd", t = "bdace"`: The function should return `'e'`.
    - `s = "", t = "y"`: The function should return `'y'`.
    - `s = "a", t = "aa"`: The function should return `'a'`.

---

### Brute Force Approach

**Explanation:**
- Initial thought process: Compare each character in `s` with each character in `t` to find the character that appears more times in `t`.
- Step-by-step breakdown of the solution:
    1. Create a frequency map of characters in `s`.
    2. Iterate over each character in `t`. For each character, decrement its count in the frequency map if it exists.
    3. The character that is left with a count of 1 in `t` (or is not in the map) is the added character.
- Why this approach comes to mind first: It is a straightforward approach that involves comparing each character in `s` with each character in `t`.

```cpp
string findTheDifference(string s, string t) {
    unordered_map<char, int> count;
    for (char c : s) {
        count[c]++;
    }
    for (char c : t) {
        if (count.find(c) != count.end()) {
            count[c]--;
            if (count[c] == 0) {
                count.erase(c);
            }
        } else {
            return c;
        }
    }
    return '\0'; // This should not happen according to the problem statement
}
```

> Complexity Analysis:
> - **Time Complexity:** $O(n + m)$, where $n$ and $m$ are the lengths of `s` and `t`, respectively.
> - **Space Complexity:** $O(n)$, for storing the frequency map of characters in `s`.
> - **Why these complexities occur:** The time complexity is linear because we are iterating over each character in `s` and `t` once. The space complexity is also linear because in the worst case, we might have to store all characters from `s` in the frequency map.

---

### Optimal Approach (Required)

**Explanation:**
- Key insight that leads to optimal solution: We can use the XOR operation to find the added character. The XOR of all characters in `s` and `t` will give us the added character because XOR of all characters in `s` will cancel out and we will be left with the added character.
- Detailed breakdown of the approach:
    1. Initialize a variable `result` to 0.
    2. Iterate over each character in `s` and `t`. For each character, XOR it with `result`.
    3. The final value of `result` will be the added character.
- Proof of optimality: This approach is optimal because it only requires a single pass through `s` and `t`, resulting in a time complexity of $O(n + m)$.

```cpp
string findTheDifference(string s, string t) {
    int result = 0;
    for (char c : s) {
        result ^= c;
    }
    for (char c : t) {
        result ^= c;
    }
    return string(1, result);
}
```

> Complexity Analysis:
> - **Time Complexity:** $O(n + m)$, where $n$ and $m$ are the lengths of `s` and `t`, respectively.
> - **Space Complexity:** $O(1)$, because we only need a constant amount of space to store the result.
> - **Optimality proof:** This approach is optimal because it only requires a single pass through `s` and `t`, resulting in a time complexity of $O(n + m)$. The space complexity is also optimal because we only need a constant amount of space.

---

### Alternative Approach

**Explanation:**
- Different perspective or technique: We can use the `std::unordered_map` to count the frequency of each character in `s` and `t`, and then find the character that appears more times in `t`.
- Unique trade-offs: This approach has a higher space complexity than the optimal approach, but it is more intuitive and easier to understand.
- Scenarios where this approach might be preferred: This approach might be preferred when readability and maintainability are more important than performance.

```cpp
string findTheDifference(string s, string t) {
    unordered_map<char, int> countS;
    unordered_map<char, int> countT;
    for (char c : s) {
        countS[c]++;
    }
    for (char c : t) {
        countT[c]++;
    }
    for (auto& pair : countT) {
        if (countS.find(pair.first) == countS.end() || pair.second > countS[pair.first]) {
            return pair.first;
        }
    }
    return '\0'; // This should not happen according to the problem statement
}
```

> Complexity Analysis:
> - **Time Complexity:** $O(n + m)$, where $n$ and $m$ are the lengths of `s` and `t`, respectively.
> - **Space Complexity:** $O(n + m)$, for storing the frequency maps of characters in `s` and `t`.
> - **Trade-off analysis:** This approach has a higher space complexity than the optimal approach, but it is more intuitive and easier to understand. It might be preferred when readability and maintainability are more important than performance.

---

### Final Notes

**Learning Points:**
- Key algorithmic concepts demonstrated: 
    - **XOR operation**: The XOR operation can be used to find the added character because XOR of all characters in `s` will cancel out and we will be left with the added character.
    - **Frequency counting**: We can use frequency counting to find the character that appears more times in `t`.
- Problem-solving patterns identified: 
    - **Single pass through data**: We can solve the problem by making a single pass through `s` and `t`.
    - **Using data structures**: We can use data structures like `std::unordered_map` to store the frequency of each character.
- Optimization techniques learned: 
    - **Reducing space complexity**: We can reduce the space complexity by using a single variable to store the result instead of a frequency map.
    - **Improving time complexity**: We can improve the time complexity by using a single pass through `s` and `t`.
- Similar problems to practice: 
    - **Single Number**: Given a non-empty array of integers, every element appears twice except for one. Find that single one.
    - **Find the Duplicate Number**: Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive, there is only one duplicate number in `nums`, return this duplicate number.

**Mistakes to Avoid:**
- Common implementation errors: 
    - **Not handling edge cases**: We should handle edge cases like empty strings or strings with only one character.
    - **Not checking for null or empty input**: We should check for null or empty input and handle it accordingly.
- Edge cases to watch for: 
    - **Empty strings**: We should handle empty strings as edge cases.
    - **Strings with only one character**: We should handle strings with only one character as edge cases.
- Performance pitfalls: 
    - **Using unnecessary data structures**: We should avoid using unnecessary data structures like frequency maps when a single variable can be used to store the result.
    - **Making multiple passes through data**: We should avoid making multiple passes through `s` and `t` when a single pass can be used to solve the problem.
- Testing considerations: 
    - **Testing with edge cases**: We should test the solution with edge cases like empty strings or strings with only one character.
    - **Testing with large input**: We should test the solution with large input to ensure it can handle it efficiently.