## Minimize Malware Spread
**Problem Link:** https://leetcode.com/problems/minimize-malware-spread/description

**Problem Statement:**
- Input format: `graph` as an adjacency list representation of a graph, and `initial` as a list of initially infected nodes.
- Constraints: `1 <= graph.length <= 10^5`, `1 <= initial.length <= graph.length`, and `0 <= initial[i] < graph.length`.
- Expected output format: The node that, if removed, would minimize the spread of malware.
- Key requirements: Find the node with the minimum number of connected components if it were removed.
- Edge cases to consider: If there are multiple nodes with the minimum number of connected components, return the node with the smallest index.

---

### Brute Force Approach

**Explanation:**
- Initial thought process: For each node in the graph, temporarily remove it and count the number of connected components.
- Step-by-step breakdown of the solution:
  1. Iterate over each node in the graph.
  2. For each node, temporarily remove it from the graph.
  3. Count the number of connected components in the graph using DFS or BFS.
  4. Restore the node to the graph.
  5. Keep track of the node with the minimum number of connected components.
- Why this approach comes to mind first: It is a straightforward way to solve the problem, but it has high time complexity due to the repeated removal and restoration of nodes.

```cpp
#include <vector>
#include <unordered_set>

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    int minNode = -1;
    int minCount = INT_MAX;
    
    for (int i = 0; i < n; i++) {
        vector<vector<int>> tempGraph = graph;
        unordered_set<int> visited;
        
        // Temporarily remove node i from the graph
        tempGraph[i].clear();
        for (int j = 0; j < n; j++) {
            if (find(tempGraph[j].begin(), tempGraph[j].end(), i) != tempGraph[j].end()) {
                tempGraph[j].erase(find(tempGraph[j].begin(), tempGraph[j].end(), i));
            }
        }
        
        int count = 0;
        for (int j = 0; j < n; j++) {
            if (find(visited.begin(), visited.end(), j) == visited.end()) {
                count++;
                dfs(tempGraph, visited, j);
            }
        }
        
        if (count < minCount) {
            minCount = count;
            minNode = i;
        } else if (count == minCount && i < minNode) {
            minNode = i;
        }
    }
    
    return minNode;
}

void dfs(vector<vector<int>>& graph, unordered_set<int>& visited, int node) {
    visited.insert(node);
    for (int neighbor : graph[node]) {
        if (find(visited.begin(), visited.end(), neighbor) == visited.end()) {
            dfs(graph, visited, neighbor);
        }
    }
}
```

> Complexity Analysis:
> - **Time Complexity:** $O(n^3)$, where $n$ is the number of nodes in the graph. This is because we are iterating over each node, and for each node, we are temporarily removing it and counting the number of connected components.
> - **Space Complexity:** $O(n)$, where $n$ is the number of nodes in the graph. This is because we are using a temporary graph and a visited set to keep track of the nodes we have visited.
> - **Why these complexities occur:** The high time complexity occurs because we are repeatedly removing and restoring nodes from the graph, and counting the number of connected components. The space complexity occurs because we are using a temporary graph and a visited set.

---

### Optimal Approach (Required)

**Explanation:**
- Key insight that leads to optimal solution: Instead of temporarily removing each node and counting the number of connected components, we can use a Union-Find data structure to keep track of the connected components.
- Detailed breakdown of the approach:
  1. Initialize a Union-Find data structure with each node as its own parent.
  2. Iterate over each edge in the graph and union the two nodes.
  3. Keep track of the parent of each node and the size of each connected component.
  4. Iterate over each initially infected node and find the parent of the node.
  5. If the node is the parent of the connected component, increment the count of the component.
  6. Find the node with the minimum count and return it.
- Proof of optimality: This approach is optimal because it uses a Union-Find data structure to keep track of the connected components, which has an average time complexity of $O(\alpha(n))$, where $\alpha(n)$ is the inverse Ackermann function.

```cpp
class UnionFind {
public:
    vector<int> parent;
    vector<int> size;
    
    UnionFind(int n) {
        parent.resize(n);
        size.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    void unionNodes(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (size[rootX] < size[rootY]) {
                parent[rootX] = rootY;
                size[rootY] += size[rootX];
            } else {
                parent[rootY] = rootX;
                size[rootX] += size[rootY];
            }
        }
    }
};

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    UnionFind uf(n);
    
    for (int i = 0; i < n; i++) {
        for (int j : graph[i]) {
            uf.unionNodes(i, j);
        }
    }
    
    unordered_map<int, int> count;
    for (int node : initial) {
        int parent = uf.find(node);
        count[parent]++;
    }
    
    int minNode = -1;
    int minCount = INT_MAX;
    for (int node : initial) {
        int parent = uf.find(node);
        if (count[parent] == 1 && uf.size[parent] < minCount) {
            minCount = uf.size[parent];
            minNode = node;
        } else if (count[parent] == 1 && uf.size[parent] == minCount && node < minNode) {
            minNode = node;
        }
    }
    
    if (minNode == -1) {
        int minVal = INT_MAX;
        for (int node : initial) {
            if (node < minVal) {
                minVal = node;
                minNode = node;
            }
        }
    }
    
    return minNode;
}
```

> Complexity Analysis:
> - **Time Complexity:** $O(n + m \alpha(n))$, where $n$ is the number of nodes and $m$ is the number of edges in the graph. This is because we are using a Union-Find data structure to keep track of the connected components.
> - **Space Complexity:** $O(n)$, where $n$ is the number of nodes in the graph. This is because we are using a Union-Find data structure to keep track of the connected components.
> - **Optimality proof:** This approach is optimal because it uses a Union-Find data structure to keep track of the connected components, which has an average time complexity of $O(\alpha(n))$, where $\alpha(n)$ is the inverse Ackermann function.

---

### Final Notes

**Learning Points:**
- Key algorithmic concepts demonstrated: Union-Find data structure, graph traversal, and optimization techniques.
- Problem-solving patterns identified: Using a Union-Find data structure to keep track of connected components, and optimizing the solution by using a single pass over the graph.
- Optimization techniques learned: Using a Union-Find data structure to reduce the time complexity of the solution.
- Similar problems to practice: Other graph traversal and optimization problems, such as finding the minimum spanning tree or the shortest path in a graph.

**Mistakes to Avoid:**
- Common implementation errors: Not using a Union-Find data structure to keep track of connected components, or not optimizing the solution by using a single pass over the graph.
- Edge cases to watch for: Handling the case where there are multiple nodes with the minimum count, or handling the case where the graph is empty.
- Performance pitfalls: Not using a Union-Find data structure to keep track of connected components, or not optimizing the solution by using a single pass over the graph.
- Testing considerations: Testing the solution with different graph sizes and structures, and testing the solution with different initial infection nodes.