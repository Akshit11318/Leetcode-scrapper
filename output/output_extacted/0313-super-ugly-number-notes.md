## Super Ugly Number
**Problem Link:** https://leetcode.com/problems/super-ugly-number/description

**Problem Statement:**
- Input: An integer `n` and a list of primes `primes`.
- Constraints: `1 <= n <= 10^5` and `1 <= primes.length <= 100`, where `1 <= primes[i] <= 10^5`.
- Expected Output: The `n`-th super ugly number.
- Key Requirements: A super ugly number is a positive integer whose prime factors are in the list `primes`.
- Example Test Cases:
  - Input: `n = 12, primes = [2,7,13,19]`
  - Output: `32`
  - Explanation: `[1,2,4,7,8,13,14,19,26,28,32]` are the first 12 super ugly numbers.

---

### Brute Force Approach

**Explanation:**
- Initial thought process: Generate all numbers up to a certain limit and check if they are super ugly.
- Step-by-step breakdown of the solution:
  1. Initialize an empty list to store super ugly numbers.
  2. Start from 1 and check each number to see if it's super ugly by dividing it by all primes until it's no longer divisible.
  3. If a number is super ugly, add it to the list.
  4. Continue until we find `n` super ugly numbers.
- Why this approach comes to mind first: It's a straightforward method to generate and check numbers.

```cpp
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        vector<int> ugly;
        ugly.push_back(1);
        int i = 0;
        while (ugly.size() < n) {
            int num = ugly[i] * primes[0];
            for (int j = 1; j < primes.size(); j++) {
                if (ugly[i] * primes[j] < num) {
                    num = ugly[i] * primes[j];
                }
            }
            ugly.push_back(num);
            i++;
        }
        return ugly.back();
    }
};
```

> Complexity Analysis:
> - **Time Complexity:** $O(n^2)$, where $n$ is the number of super ugly numbers to find, because in the worst case, we might have to iterate through all previous super ugly numbers for each new one.
> - **Space Complexity:** $O(n)$, as we store all super ugly numbers found so far.
> - **Why these complexities occur:** The nested loop structure (checking each number against all primes) leads to quadratic time complexity, and storing all super ugly numbers leads to linear space complexity.

---

### Optimal Approach (Required)

**Explanation:**
- Key insight: Use a dynamic programming approach with multiple pointers, one for each prime number, to keep track of the next potential super ugly number that can be generated by multiplying each prime with the current super ugly numbers.
- Detailed breakdown of the approach:
  1. Initialize a list with the first super ugly number, which is 1.
  2. For each prime, maintain a pointer to the current super ugly number that we are considering for multiplication.
  3. At each step, find the minimum of the next potential super ugly numbers that can be generated by multiplying the current super ugly numbers with each prime.
  4. Add this minimum to the list of super ugly numbers and move the corresponding pointers forward.
- Proof of optimality: This approach ensures that we generate super ugly numbers in ascending order without missing any, and it does so in linear time complexity regarding the number of super ugly numbers we need to find.

```cpp
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        vector<int> ugly(n);
        ugly[0] = 1;
        vector<int> indices(primes.size(), 0);
        
        for (int i = 1; i < n; i++) {
            int minVal = INT_MAX;
            for (int j = 0; j < primes.size(); j++) {
                minVal = min(minVal, ugly[indices[j]] * primes[j]);
            }
            ugly[i] = minVal;
            for (int j = 0; j < primes.size(); j++) {
                if (ugly[indices[j]] * primes[j] == minVal) {
                    indices[j]++;
                }
            }
        }
        return ugly[n-1];
    }
};
```

> Complexity Analysis:
> - **Time Complexity:** $O(n \cdot m)$, where $n$ is the number of super ugly numbers to find and $m$ is the number of primes, because we potentially check each prime for each super ugly number.
> - **Space Complexity:** $O(n + m)$, for storing the super ugly numbers and the indices for each prime.
> - **Optimality proof:** This is optimal because we only generate and check each super ugly number once, and we do so in a manner that ensures we find them in ascending order without needing to check all numbers up to a certain limit.

---

### Final Notes

**Learning Points:**
- Key algorithmic concepts: Dynamic programming, multiple pointers technique.
- Problem-solving patterns: Using pointers to track the next potential values in a sequence.
- Optimization techniques: Avoiding redundant calculations by only considering the minimum next potential values.

**Mistakes to Avoid:**
- Not initializing pointers correctly.
- Missing the update of pointers after finding a new super ugly number.
- Not handling edge cases, such as when `n` is 1 or when the list of primes is empty.