## Minimize Malware Spread II
**Problem Link:** https://leetcode.com/problems/minimize-malware-spread-ii/description

**Problem Statement:**
- Input format: `graph` - a 2D array representing the connections between nodes, `initial` - a list of initially infected nodes.
- Constraints: $1 \leq \text{number of nodes} \leq 10^4$, $0 \leq \text{number of edges} \leq 10^5$, $1 \leq \text{number of initially infected nodes} \leq 10^4$.
- Expected output format: The minimum number of nodes that will be infected after removing one node.
- Key requirements and edge cases to consider: Handling the case where all nodes are initially infected, and the case where no nodes are initially infected.
- Example test cases with explanations:
  - Example 1:
    - Input: `graph = [[1,1,0],[1,1,0],[0,0,1]]`, `initial = [0,1]`
    - Output: 0
    - Explanation: Removing node 2 will prevent the malware from spreading.
  - Example 2:
    - Input: `graph = [[1,0,0],[0,1,0],[0,0,1]]`, `initial = [0,2]`
    - Output: 0
    - Explanation: Removing either node 0 or node 2 will prevent the malware from spreading.

---

### Brute Force Approach

**Explanation:**
- Initial thought process: For each node in the graph, remove it from the graph and calculate the number of nodes that will be infected.
- Step-by-step breakdown of the solution:
  1. Iterate over each node in the graph.
  2. For each node, create a copy of the graph and remove the node from the copy.
  3. Perform a depth-first search (DFS) from each initially infected node to calculate the number of nodes that will be infected.
  4. Keep track of the minimum number of nodes that will be infected after removing one node.
- Why this approach comes to mind first: It is a straightforward approach that tries all possible solutions and keeps track of the best one.

```cpp
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int minInfected = n;
        int removeNode = -1;
        
        for (int i = 0; i < n; i++) {
            vector<int> infected;
            vector<vector<int>> graphCopy = graph;
            // Remove node i from the graph copy
            for (int j = 0; j < n; j++) {
                graphCopy[i][j] = 0;
                graphCopy[j][i] = 0;
            }
            
            // Perform DFS from each initially infected node
            vector<bool> visited(n, false);
            for (int init : initial) {
                if (init != i) {
                    dfs(graphCopy, init, visited, infected);
                }
            }
            
            if (infected.size() < minInfected) {
                minInfected = infected.size();
                removeNode = i;
            } else if (infected.size() == minInfected) {
                // If the number of infected nodes is the same, remove the node with the smallest index
                if (i < removeNode) {
                    removeNode = i;
                }
            }
        }
        
        return removeNode;
    }
    
    void dfs(vector<vector<int>>& graph, int node, vector<bool>& visited, vector<int>& infected) {
        if (visited[node]) return;
        visited[node] = true;
        infected.push_back(node);
        
        for (int i = 0; i < graph.size(); i++) {
            if (graph[node][i] == 1 && !visited[i]) {
                dfs(graph, i, visited, infected);
            }
        }
    }
};
```

> Complexity Analysis:
> - **Time Complexity:** $O(n^3)$, where $n$ is the number of nodes in the graph. The reason for this complexity is that for each node, we are creating a copy of the graph and performing a DFS from each initially infected node.
> - **Space Complexity:** $O(n^2)$, where $n$ is the number of nodes in the graph. The reason for this complexity is that we are creating a copy of the graph for each node.
> - **Why these complexities occur:** The brute force approach tries all possible solutions and keeps track of the best one, which results in high time and space complexities.

---

### Optimal Approach (Required)

**Explanation:**
- Key insight that leads to optimal solution: Instead of creating a copy of the graph for each node, we can use a union-find data structure to keep track of the connected components in the graph.
- Detailed breakdown of the approach:
  1. Initialize a union-find data structure with each node in its own set.
  2. Iterate over the edges in the graph and union the sets of the nodes that are connected by each edge.
  3. For each initially infected node, find the set that it belongs to and mark all nodes in that set as infected.
  4. Iterate over the nodes in the graph and for each node, check if removing it would reduce the number of infected nodes.
- Proof of optimality: This approach is optimal because it uses a union-find data structure to keep track of the connected components in the graph, which reduces the time complexity from $O(n^3)$ to $O(n + m)$, where $n$ is the number of nodes and $m$ is the number of edges.

```cpp
class UnionFind {
public:
    vector<int> parent;
    vector<int> size;
    
    UnionFind(int n) {
        parent.resize(n);
        size.resize(n, 1);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    void unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (size[rootX] < size[rootY]) {
                parent[rootX] = rootY;
                size[rootY] += size[rootX];
            } else {
                parent[rootY] = rootX;
                size[rootX] += size[rootY];
            }
        }
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        UnionFind uf(n);
        
        // Union the sets of the nodes that are connected by each edge
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) {
                    uf.unionSets(i, j);
                }
            }
        }
        
        // Mark all nodes in the same set as an initially infected node as infected
        vector<int> infectedCount(n, 0);
        for (int init : initial) {
            int root = uf.find(init);
            infectedCount[root]++;
        }
        
        int minInfected = n;
        int removeNode = -1;
        
        for (int i = 0; i < n; i++) {
            int root = uf.find(i);
            if (infectedCount[root] == 1) {
                if (uf.size[root] < minInfected) {
                    minInfected = uf.size[root];
                    removeNode = i;
                } else if (uf.size[root] == minInfected) {
                    // If the number of infected nodes is the same, remove the node with the smallest index
                    if (i < removeNode) {
                        removeNode = i;
                    }
                }
            }
        }
        
        if (removeNode == -1) {
            // If no node can be removed to reduce the number of infected nodes, return the node with the smallest index
            int minIndex = INT_MAX;
            for (int init : initial) {
                if (init < minIndex) {
                    minIndex = init;
                }
            }
            return minIndex;
        }
        
        return removeNode;
    }
};
```

> Complexity Analysis:
> - **Time Complexity:** $O(n + m)$, where $n$ is the number of nodes and $m$ is the number of edges. The reason for this complexity is that we are using a union-find data structure to keep track of the connected components in the graph.
> - **Space Complexity:** $O(n)$, where $n$ is the number of nodes. The reason for this complexity is that we are using a union-find data structure to keep track of the connected components in the graph.
> - **Optimality proof:** This approach is optimal because it uses a union-find data structure to keep track of the connected components in the graph, which reduces the time complexity from $O(n^3)$ to $O(n + m)$.

---

### Final Notes

**Learning Points:**
- Key algorithmic concepts demonstrated: Union-find data structure, graph traversal.
- Problem-solving patterns identified: Using a union-find data structure to keep track of connected components in a graph.
- Optimization techniques learned: Reducing time complexity by using a union-find data structure.
- Similar problems to practice: Problems that involve graph traversal and connected components, such as finding the number of connected components in a graph.

**Mistakes to Avoid:**
- Common implementation errors: Not handling the case where all nodes are initially infected, or not handling the case where no nodes are initially infected.
- Edge cases to watch for: Handling the case where the graph is empty, or handling the case where the graph has only one node.
- Performance pitfalls: Using a brute force approach that tries all possible solutions, which can result in high time complexity.
- Testing considerations: Testing the solution with different inputs, including edge cases, to ensure that it works correctly.